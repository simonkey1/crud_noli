name: Auto Restore from Backup

on:
  # Permitir ejecución manual
  workflow_dispatch:
    inputs:
      backup_artifact_name:
        description: 'Nombre del artifact de backup a usar (opcional)'
        required: false
        default: 'pre-deploy-backup'
      force_restore:
        description: 'Forzar restauración incluso si la DB no está vacía'
        type: boolean
        required: false
        default: false

  # Ejecutar automáticamente después de cada deploy exitoso
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed

jobs:
  check-and-restore:
    runs-on: ubuntu-latest
    # Ejecutar si es manual O si el deploy fue exitoso (para verificar/restaurar DB)
    if: >
      github.event_name == 'workflow_dispatch' || 
      (github.event.workflow_run.conclusion == 'success' && 
       github.event.workflow_run.event == 'push')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Configure environment
        run: |
          echo "DATABASE_URL=${{ secrets.DATABASE_URL || env.DATABASE_URL }}" >> $GITHUB_ENV
          echo "JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY || 'fallback-key-for-restore' }}" >> $GITHUB_ENV
          echo "ENVIRONMENT=production" >> $GITHUB_ENV
          echo "POSTGRES_USER=${{ secrets.POSTGRES_USER || env.POSTGRES_USER }}" >> $GITHUB_ENV
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || env.POSTGRES_PASSWORD }}" >> $GITHUB_ENV
          echo "POSTGRES_DB=${{ secrets.POSTGRES_DB || env.POSTGRES_DB }}" >> $GITHUB_ENV
          echo "POSTGRES_SERVER=${{ secrets.POSTGRES_SERVER || env.POSTGRES_SERVER }}" >> $GITHUB_ENV
          echo "POSTGRES_PORT=${{ secrets.POSTGRES_PORT || env.POSTGRES_PORT || '5432' }}" >> $GITHUB_ENV

      # Determinar qué artifact usar
      - name: Determine backup source
        id: backup-source
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Uso manual - usar el artifact especificado o el más reciente
            ARTIFACT_NAME="${{ inputs.backup_artifact_name || 'pre-deploy-backup' }}"
            echo "source=manual" >> $GITHUB_OUTPUT
            echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
            echo "🔧 Activación manual - artifact: $ARTIFACT_NAME"
          else
            # Deploy exitoso - usar el backup del workflow que acaba de completarse
            echo "source=post_deploy" >> $GITHUB_OUTPUT
            echo "artifact_name=pre-deploy-backup" >> $GITHUB_OUTPUT
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "🚀 Post-deploy automático - verificando si DB necesita restauración"
          fi

      # Descargar artifact de backup
      - name: Download backup artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.backup-source.outputs.artifact_name }}
          path: ./downloaded-backup
          # Si es desde un workflow específico, usar el run_id
          run-id: ${{ steps.backup-source.outputs.run_id || '' }}

      # Verificar contenido del backup descargado
      - name: Verify backup content
        id: verify-backup
        run: |
          echo "🔍 Verificando contenido del backup descargado..."
          ls -la ./downloaded-backup/
          
          # Buscar archivos .zip de backup
          BACKUP_FILE=$(find ./downloaded-backup -name "backup_*.zip" | head -1)
          
          if [ -z "$BACKUP_FILE" ]; then
            echo "❌ No se encontró archivo de backup en el artifact"
            exit 1
          fi
          
          echo "✅ Backup encontrado: $BACKUP_FILE"
          echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          
          # Verificar integridad del archivo
          if unzip -t "$BACKUP_FILE" > /dev/null 2>&1; then
            echo "✅ Archivo de backup es válido"
          else
            echo "❌ Archivo de backup está corrupto"
            exit 1
          fi

      # Verificar estado de la base de datos antes de restaurar
      - name: Check database status
        id: db-status
        run: |
          echo "🔍 Verificando estado de la base de datos..."
          python -c "
          import sys
          sys.path.append('.')
          
          try:
              from scripts.backup_database import check_database_status
              status = check_database_status()
              print(f'Estado de la DB: {status}')
              
              # Para post-deploy: restaurar si tiene pocos registros (DB probablemente vacía)
              # Para manual: restaurar según force_restore o si está vacía
              total_records = status.get('total_records', 0)
              
              if '${{ github.event_name }}' == 'workflow_dispatch':
                  # Activación manual
                  needs_restore = (
                      total_records == 0 or 
                      '${{ inputs.force_restore }}' == 'true'
                  )
                  print(f'Modo manual - Total: {total_records}, Force: ${{ inputs.force_restore }}')
              else:
                  # Post-deploy automático - más agresivo en restaurar
                  needs_restore = total_records < 10  # Si tiene menos de 10 registros, probablemente está vacía
                  print(f'Modo post-deploy - Total: {total_records}, Umbral: 10')
              
              print(f'Necesita restauración: {needs_restore}')
              print(f'needs_restore={str(needs_restore).lower()}')
              
          except Exception as e:
              print(f'Error verificando DB: {e}')
              print('needs_restore=true')  # En caso de error, asumir que necesita restauración
          " | tee db_status.log
          
          # Extraer el resultado
          NEEDS_RESTORE=$(grep "needs_restore=" db_status.log | cut -d'=' -f2)
          echo "needs_restore=$NEEDS_RESTORE" >> $GITHUB_OUTPUT

      # Restaurar backup si es necesario
      - name: Restore backup
        if: steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "🔄 Iniciando restauración del backup..."
          echo "Archivo: ${{ steps.verify-backup.outputs.backup_file }}"
          
          # Crear directorio de backups y copiar el archivo
          mkdir -p backups
          cp "${{ steps.verify-backup.outputs.backup_file }}" backups/
          
          # Ejecutar restauración
          BACKUP_NAME=$(basename "${{ steps.verify-backup.outputs.backup_file }}" .zip)
          echo "Restaurando desde: $BACKUP_NAME"
          
          python -m scripts.restore_from_backup "$BACKUP_NAME"

      # Verificar que la restauración fue exitosa
      - name: Verify restoration
        if: steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "✅ Verificando restauración..."
          python -c "
          import sys
          sys.path.append('.')
          
          try:
              from scripts.backup_database import check_database_status
              status = check_database_status()
              
              print('📊 Estado post-restauración:')
              for table, count in status.items():
                  if table != 'total_records':
                      print(f'  {table}: {count} registros')
              
              print(f'Total de registros: {status.get(\"total_records\", 0)}')
              
              if status.get('total_records', 0) > 0:
                  print('✅ Restauración exitosa!')
              else:
                  print('❌ La restauración falló - base de datos sigue vacía')
                  sys.exit(1)
                  
          except Exception as e:
              print(f'❌ Error verificando restauración: {e}')
              sys.exit(1)
          "

      # Verificar conectividad de la aplicación (opcional)
      - name: Test database connectivity
        if: steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "🔍 Verificando conectividad de la base de datos..."
          
          # Verificar que la base de datos responde
          python -c "
          import sys
          sys.path.append('.')
          
          try:
              from scripts.backup_database import check_database_status
              status = check_database_status()
              
              if 'error' in status:
                  print(f'❌ Error de conectividad: {status[\"error\"]}')
                  sys.exit(1)
              else:
                  print('✅ Base de datos responde correctamente')
                  print(f'📊 Total de registros: {status.get(\"total_records\", 0)}')
                  
          except Exception as e:
              print(f'❌ Error verificando conectividad: {e}')
              sys.exit(1)
          "

      # Limpiar archivos temporales
      - name: Cleanup
        if: always()
        run: |
          echo "🧹 Limpiando archivos temporales..."
          rm -rf ./downloaded-backup
          rm -f db_status.log

      # Notificación de éxito
      - name: Notify success
        if: success() && steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "🎉 ¡Restauración automática completada exitosamente!"
          echo "📊 La base de datos ha sido restaurada desde el backup"
          echo "🔗 Backup utilizado: ${{ steps.backup-source.outputs.artifact_name }}"
          echo "🎯 Tipo de activación: ${{ steps.backup-source.outputs.source }}"
          
          if [ "${{ steps.backup-source.outputs.source }}" == "post_deploy" ]; then
            echo "✅ Deploy completado y base de datos restaurada automáticamente"
          else
            echo "✅ Restauración manual completada"
          fi

      # Notificación si no se necesitó restauración
      - name: Notify no action needed
        if: success() && steps.db-status.outputs.needs_restore == 'false'
        run: |
          echo "ℹ️ No se requirió restauración"
          
          if [ "${{ steps.backup-source.outputs.source }}" == "post_deploy" ]; then
            echo "✅ Deploy completado - La base de datos ya contiene datos suficientes"
          else
            echo "📊 La base de datos ya contiene datos"
            echo "💡 Usa 'force_restore: true' para forzar la restauración"
          fi
