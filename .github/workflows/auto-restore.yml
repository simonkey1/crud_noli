name: Auto Restore from Backup

on:
  # Permitir ejecuciÃ³n manual
  workflow_dispatch:
    inputs:
      backup_artifact_name:
        description: 'Nombre del artifact de backup a usar (opcional)'
        required: false
        default: 'pre-deploy-backup'
      force_restore:
        description: 'Forzar restauraciÃ³n incluso si la DB no estÃ¡ vacÃ­a'
        type: boolean
        required: false
        default: false

  # Ejecutar automÃ¡ticamente despuÃ©s de cada deploy exitoso
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed

jobs:
  check-and-restore:
    runs-on: ubuntu-latest
    # Ejecutar si es manual O si el deploy fue exitoso (para verificar/restaurar DB)
    if: >
      github.event_name == 'workflow_dispatch' || 
      (github.event.workflow_run.conclusion == 'success' && 
       github.event.workflow_run.event == 'push')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Configure environment
        run: |
          echo "DATABASE_URL=${{ secrets.DATABASE_URL || env.DATABASE_URL }}" >> $GITHUB_ENV
          echo "JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY || 'fallback-key-for-restore' }}" >> $GITHUB_ENV
          echo "ENVIRONMENT=production" >> $GITHUB_ENV
          echo "POSTGRES_USER=${{ secrets.POSTGRES_USER || env.POSTGRES_USER }}" >> $GITHUB_ENV
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || env.POSTGRES_PASSWORD }}" >> $GITHUB_ENV
          echo "POSTGRES_DB=${{ secrets.POSTGRES_DB || env.POSTGRES_DB }}" >> $GITHUB_ENV
          echo "POSTGRES_SERVER=${{ secrets.POSTGRES_SERVER || env.POSTGRES_SERVER }}" >> $GITHUB_ENV
          echo "POSTGRES_PORT=${{ secrets.POSTGRES_PORT || env.POSTGRES_PORT || '5432' }}" >> $GITHUB_ENV

      # Determinar quÃ© artifact usar
      - name: Determine backup source
        id: backup-source
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Uso manual - usar el artifact especificado o el mÃ¡s reciente
            ARTIFACT_NAME="${{ inputs.backup_artifact_name || 'pre-deploy-backup' }}"
            echo "source=manual" >> $GITHUB_OUTPUT
            echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
            echo "ğŸ”§ ActivaciÃ³n manual - artifact: $ARTIFACT_NAME"
          else
            # Deploy exitoso - usar el backup del workflow que acaba de completarse
            echo "source=post_deploy" >> $GITHUB_OUTPUT
            echo "artifact_name=pre-deploy-backup" >> $GITHUB_OUTPUT
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "ğŸš€ Post-deploy automÃ¡tico - verificando si DB necesita restauraciÃ³n"
          fi

      # Descargar artifact de backup
      - name: Download backup artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.backup-source.outputs.artifact_name }}
          path: ./downloaded-backup
          # Si es desde un workflow especÃ­fico, usar el run_id
          run-id: ${{ steps.backup-source.outputs.run_id || '' }}

      # Verificar contenido del backup descargado
      - name: Verify backup content
        id: verify-backup
        run: |
          echo "ğŸ” Verificando contenido del backup descargado..."
          ls -la ./downloaded-backup/
          
          # Buscar archivos .zip de backup
          BACKUP_FILE=$(find ./downloaded-backup -name "backup_*.zip" | head -1)
          
          if [ -z "$BACKUP_FILE" ]; then
            echo "âŒ No se encontrÃ³ archivo de backup en el artifact"
            exit 1
          fi
          
          echo "âœ… Backup encontrado: $BACKUP_FILE"
          echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          
          # Verificar integridad del archivo
          if unzip -t "$BACKUP_FILE" > /dev/null 2>&1; then
            echo "âœ… Archivo de backup es vÃ¡lido"
          else
            echo "âŒ Archivo de backup estÃ¡ corrupto"
            exit 1
          fi

      # Verificar estado de la base de datos antes de restaurar
      - name: Check database status
        id: db-status
        run: |
          echo "ğŸ” Verificando estado de la base de datos..."
          python -c "
          import sys
          sys.path.append('.')
          
          try:
              from scripts.backup_database import check_database_status
              status = check_database_status()
              print(f'Estado de la DB: {status}')
              
              # Para post-deploy: restaurar si tiene pocos registros (DB probablemente vacÃ­a)
              # Para manual: restaurar segÃºn force_restore o si estÃ¡ vacÃ­a
              total_records = status.get('total_records', 0)
              
              if '${{ github.event_name }}' == 'workflow_dispatch':
                  # ActivaciÃ³n manual
                  needs_restore = (
                      total_records == 0 or 
                      '${{ inputs.force_restore }}' == 'true'
                  )
                  print(f'Modo manual - Total: {total_records}, Force: ${{ inputs.force_restore }}')
              else:
                  # Post-deploy automÃ¡tico - mÃ¡s agresivo en restaurar
                  needs_restore = total_records < 10  # Si tiene menos de 10 registros, probablemente estÃ¡ vacÃ­a
                  print(f'Modo post-deploy - Total: {total_records}, Umbral: 10')
              
              print(f'Necesita restauraciÃ³n: {needs_restore}')
              print(f'needs_restore={str(needs_restore).lower()}')
              
          except Exception as e:
              print(f'Error verificando DB: {e}')
              print('needs_restore=true')  # En caso de error, asumir que necesita restauraciÃ³n
          " | tee db_status.log
          
          # Extraer el resultado
          NEEDS_RESTORE=$(grep "needs_restore=" db_status.log | cut -d'=' -f2)
          echo "needs_restore=$NEEDS_RESTORE" >> $GITHUB_OUTPUT

      # Restaurar backup si es necesario
      - name: Restore backup
        if: steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "ğŸ”„ Iniciando restauraciÃ³n del backup..."
          echo "Archivo: ${{ steps.verify-backup.outputs.backup_file }}"
          
          # Crear directorio de backups y copiar el archivo
          mkdir -p backups
          cp "${{ steps.verify-backup.outputs.backup_file }}" backups/
          
          # Ejecutar restauraciÃ³n
          BACKUP_NAME=$(basename "${{ steps.verify-backup.outputs.backup_file }}" .zip)
          echo "Restaurando desde: $BACKUP_NAME"
          
          python -m scripts.restore_from_backup "$BACKUP_NAME"

      # Verificar que la restauraciÃ³n fue exitosa
      - name: Verify restoration
        if: steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "âœ… Verificando restauraciÃ³n..."
          python -c "
          import sys
          sys.path.append('.')
          
          try:
              from scripts.backup_database import check_database_status
              status = check_database_status()
              
              print('ğŸ“Š Estado post-restauraciÃ³n:')
              for table, count in status.items():
                  if table != 'total_records':
                      print(f'  {table}: {count} registros')
              
              print(f'Total de registros: {status.get(\"total_records\", 0)}')
              
              if status.get('total_records', 0) > 0:
                  print('âœ… RestauraciÃ³n exitosa!')
              else:
                  print('âŒ La restauraciÃ³n fallÃ³ - base de datos sigue vacÃ­a')
                  sys.exit(1)
                  
          except Exception as e:
              print(f'âŒ Error verificando restauraciÃ³n: {e}')
              sys.exit(1)
          "

      # Verificar conectividad de la aplicaciÃ³n (opcional)
      - name: Test database connectivity
        if: steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "ğŸ” Verificando conectividad de la base de datos..."
          
          # Verificar que la base de datos responde
          python -c "
          import sys
          sys.path.append('.')
          
          try:
              from scripts.backup_database import check_database_status
              status = check_database_status()
              
              if 'error' in status:
                  print(f'âŒ Error de conectividad: {status[\"error\"]}')
                  sys.exit(1)
              else:
                  print('âœ… Base de datos responde correctamente')
                  print(f'ğŸ“Š Total de registros: {status.get(\"total_records\", 0)}')
                  
          except Exception as e:
              print(f'âŒ Error verificando conectividad: {e}')
              sys.exit(1)
          "

      # Limpiar archivos temporales
      - name: Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Limpiando archivos temporales..."
          rm -rf ./downloaded-backup
          rm -f db_status.log

      # NotificaciÃ³n de Ã©xito
      - name: Notify success
        if: success() && steps.db-status.outputs.needs_restore == 'true'
        run: |
          echo "ğŸ‰ Â¡RestauraciÃ³n automÃ¡tica completada exitosamente!"
          echo "ğŸ“Š La base de datos ha sido restaurada desde el backup"
          echo "ğŸ”— Backup utilizado: ${{ steps.backup-source.outputs.artifact_name }}"
          echo "ğŸ¯ Tipo de activaciÃ³n: ${{ steps.backup-source.outputs.source }}"
          
          if [ "${{ steps.backup-source.outputs.source }}" == "post_deploy" ]; then
            echo "âœ… Deploy completado y base de datos restaurada automÃ¡ticamente"
          else
            echo "âœ… RestauraciÃ³n manual completada"
          fi

      # NotificaciÃ³n si no se necesitÃ³ restauraciÃ³n
      - name: Notify no action needed
        if: success() && steps.db-status.outputs.needs_restore == 'false'
        run: |
          echo "â„¹ï¸ No se requiriÃ³ restauraciÃ³n"
          
          if [ "${{ steps.backup-source.outputs.source }}" == "post_deploy" ]; then
            echo "âœ… Deploy completado - La base de datos ya contiene datos suficientes"
          else
            echo "ğŸ“Š La base de datos ya contiene datos"
            echo "ğŸ’¡ Usa 'force_restore: true' para forzar la restauraciÃ³n"
          fi
